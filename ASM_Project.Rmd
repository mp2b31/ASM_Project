---
title: "ASM-Project"
author: "Eloi Campeny Roig & Maria Paraskeva"
date: "2023-12-20"
output: html_document
editor_options: 
  chunk_output_type: console
---

#Read Data
The chosen time series shows the apparent cement consumption in Spain (Construction Indicator) in thousands of tones.

Load the data and print them by month.
```{r}
serie=window(ts(read.table("cemento.dat"),start=1990,freq=12))
print(round(serie,0))
```

Plot the time series. 
```{r}
plot(serie,main="Apparent cement consumption in Spain (Thousand of tones)")
abline(v=1990:2020,col=4,lty=3)
```

# Transformations
Calculate the mean and variance per month in a matrix of 12 rows (months). Then plot the values of the annual mean against annual variance. 

```{r}
m=apply(matrix(serie,nr=12),2,mean)
v=apply(matrix(serie,nr=12),2,var)
plot(m,v,xlab="Annual Mean",ylab="Annual Variance",main="Annual Mean against Annual Variance values")
abline(lm(v~m),col=2,lty=3,lwd=2)
```

Plot the cement consumption over the years so as to gain insights into potential trends or seasonal patterns in construction activity.
Here we can clearly see that the height of the boxes (IQR) is higher for higher values of the mean, so we proceed in a change of scale. 

```{r}
boxplot(serie ~ floor(time(serie)), main = "Distribution of Time Series Data Across Time", xlab = "Year", ylab = "Cement Consumption")
```

Make a log transformation and plot the results. 
we chose the log transformation as it is easy to interpret. 

```{r}
lnserie=log(serie)
plot(lnserie, xlab = "Time", ylab = "Log Data", main = "Log transformation of Data over Time")
```

Calculate the log mean and log variance per month in a matrix of 12 rows (months).
Plot log variance against log mean.

```{r}
m=apply(matrix(lnserie,nr=12),2,mean)
v=apply(matrix(lnserie,nr=12),2,var)
plot(m,v,xlab="Annual Log Mean",ylab="Annual Log Variance",main="Annual Log Mean against Annual Log Variance values")
abline(lm(v~m),col=2,lty=3,lwd=2)
```

Plot the log cement consumption over discrete time intervals.

```{r}
boxplot(lnserie~floor(time(lnserie)), main = "Distribution of Log Data Across Time", xlab = "Year", ylab = "Log of Cement Consumption")
```

Plot the decomposition of additive time series. From top to bottom it shows:
 - Original time series
 - Trend Component
 - Seasonal Component
 - Residual Component

```{r}
plot(decompose(lnserie))
```

Seasonal plot of log data showing one subplot per month. The horizontal line in each subplot represents the mean value of the log-transformed time series. 

```{r}
monthplot(lnserie, main = "Seasonal plot of log data")
```

Plot the log-transformed data in a matrix format where each column is a different month. 
```{r}
ts.plot(matrix(lnserie,nrow=12),col=1:8, main = "Monthly Patterns in Log-Transformed Time Series Data")
```

Calculate the seasonal difference on the log data with a lag of 12. Then plot the results.

```{r}
d12lnserie=diff(lnserie,12)
plot(d12lnserie)
abline(h=0)
abline(h=mean(d12lnserie),col=2)
```

Add a differencing to the previous series with a lag of 1 and plot the results.

```{r}
d1d12lnserie=diff(d12lnserie,1)
plot(d1d12lnserie)
abline(h=0)
abline(h=mean(d1d12lnserie),col=2,lwd=2)
```

Add another differencing with a lag of 1 and plot the results. 

```{r}
d1d1d12lnserie=diff(d1d12lnserie,1)
plot(d1d1d12lnserie)
abline(h=0)
abline(h=mean(d1d12lnserie),col=2,lwd=2)
```

Show the variance of the transformed time series. The lower variance is that of the d1d12lnserie.

```{r}
var(lnserie)
var(d1d12lnserie)
var(d1d1d12lnserie)
```

Autocorrelation and partial autocorrelation function plots shown side by side for the differenced d1d12lnserie. 

```{r}
par(mfrow=c(1,2))
acf(d1d12lnserie,ylim=c(-1,1),col=c(2,rep(1,11)),lwd=2,lag.max=120, main = "ACF")
pacf(d1d12lnserie,ylim=c(-1,1),col=c(rep(1,11),2),lwd=2,lag.max=120, main = "PACF")
```

The identified models are:
 - AR(2)
 - AR(4)
 - SAR(2)?
 - SAR(4)
(i don't see it)

# Models

## Model 1 

For the model AR(2) with zero regular and seasonal differences (d=0, D=0), we test if intercept to see if it is significant.

```{r}
(mod1=arima(d1d12lnserie,order=c(2,0,0),seasonal=list(order=c(4,0,0),period=12)))
abs(mod1$coef/sqrt(diag(mod1$var.coef)))

intercept_t_ratio <- mod1$coef["intercept"] / sqrt(mod1$var.coef["intercept", "intercept"])

print(intercept_t_ratio)

```

Looking at the t-ratio we see that it is lower than 2 so the intercept is not significant. Now for the SAR(4) model:

```{r}
(mod1s=arima(lnserie,order=c(2,1,0),seasonal=list(order=c(4,1,0),period=12)))
abs(mod1s$coef/sqrt(diag(mod1s$var.coef)))
```

The AIC is lower for the model without regular and seasonal difference.
All the weights are significant. (que quieres decir aqui)

## Model 2

We follow the same practices for the model AR(4) with zero regular and seasonal differences (d=0, D=0).

```{r}
(mod2=arima(d1d12lnserie,order=c(4,0,0),seasonal=list(order=c(4,0,0),period=12)))
abs(mod2$coef/sqrt(diag(mod2$var.coef)))

intercept_t_ratio <- mod2$coef["intercept"] / sqrt(mod2$var.coef["intercept", "intercept"])

print(intercept_t_ratio)
```

Looking at the t-ratio we see that it is lower than 2 so the intercept is not significant. Now for the SAR(4) model:

```{r}
(mod2s=arima(lnserie,order=c(4,1,0),seasonal=list(order=c(4,1,0),period=12)))
abs(mod2s$coef/sqrt(diag(mod2s$var.coef)))
```

The AIC is lower for the model without regular and seasonal difference. 
Comparing the two models below we have that the first one is better.

```{r}
mod1$aic 
#mod1s$aic #SAR
mod2$aic 
#mod2s$aic #SAR
```

We finally choose the first model AR(2) as it has the lowest absolute AIC value of all models above. 

Also, the t-ratio of mod1 is greater than the t-ratio of mod2, which indicate more reliable estimates. 

# Validation

We proceed to the validation of our chosen model. 

```{r}
#################Validation#################################
validation=function(model,dades){
  s=frequency(get(model$series))
  resid=model$residuals
  par(mfrow=c(2,2),mar=c(3,3,3,3))
  #Residuals plot
  plot(resid,main="Residuals")
  abline(h=0)
  abline(h=c(-3*sd(resid),3*sd(resid)),lty=3,col=4)
  #Square Root of absolute values of residuals (Homocedasticity)
  scatter.smooth(sqrt(abs(resid)),main="Square Root of Absolute residuals",
                 lpars=list(col=2))
  
  #Normal plot of residuals
  qqnorm(resid)
  qqline(resid,col=2,lwd=2)
  
  ##Histogram of residuals with normal curve
  hist(resid,breaks=20,freq=FALSE)
  curve(dnorm(x,mean=mean(resid),sd=sd(resid)),col=2,add=T)
  
  
  #ACF & PACF of residuals
  par(mfrow=c(1,2))
  acf(resid,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,s-1)),lwd=1)
  pacf(resid,ylim=c(-1,1),lag.max=60,col=c(rep(1,s-1),2),lwd=1)
  par(mfrow=c(1,1))
  
  #ACF & PACF of square residuals 
  par(mfrow=c(1,2))
  acf(resid^2,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,s-1)),lwd=1)
  pacf(resid^2,ylim=c(-1,1),lag.max=60,col=c(rep(1,s-1),2),lwd=1)
  par(mfrow=c(1,1))
  
  #Ljung-Box p-values
  par(mar=c(2,2,1,1))
  tsdiag(model,gof.lag=7*s)
  cat("\n--------------------------------------------------------------------\n")
  print(model)
  
  #Stationary and Invertible
  cat("\nModul of AR Characteristic polynomial Roots: ", 
      Mod(polyroot(c(1,-model$model$phi))),"\n")
  cat("\nModul of MA Characteristic polynomial Roots: ",
      Mod(polyroot(c(1,model$model$theta))),"\n")
  
  suppressMessages(require(forecast,quietly=TRUE,warn.conflicts=FALSE))
  plot(model)
  
  #Model expressed as an MA infinity (psi-weights)
  psis=ARMAtoMA(ar=model$model$phi,ma=model$model$theta,lag.max=36)
  names(psis)=paste("psi",1:36)
  cat("\nPsi-weights (MA(inf))\n")
  cat("\n--------------------\n")
  print(psis[1:20])
  
  #Model expressed as an AR infinity (pi-weights)
  pis=-ARMAtoMA(ar=-model$model$theta,ma=-model$model$phi,lag.max=36)
  names(pis)=paste("pi",1:36)
  cat("\nPi-weights (AR(inf))\n")
  cat("\n--------------------\n")
  print(pis[1:20])
  
  cat("\nDescriptive Statistics for the Residuals\n")
  cat("\n----------------------------------------\n") 
  
  suppressMessages(require(fBasics,quietly=TRUE,warn.conflicts=FALSE))
  ##Anderson-Darling test
  print(basicStats(resid))
  
  ## Add here complementary tests (use with caution!)
  ##---------------------------------------------------------
  cat("\nNormality Tests\n")
  cat("\n--------------------\n")
 
  ##Shapiro-Wilks Normality test
  print(shapiro.test(resid(model)))

  suppressMessages(require(nortest,quietly=TRUE,warn.conflicts=FALSE))
  ##Anderson-Darling test
  print(ad.test(resid(model)))
  
  suppressMessages(require(tseries,quietly=TRUE,warn.conflicts=FALSE))
  ##Jarque-Bera test
  print(jarque.bera.test(resid(model)))
  
  cat("\nHomoscedasticity Test\n")
  cat("\n--------------------\n")
  suppressMessages(require(lmtest,quietly=TRUE,warn.conflicts=FALSE))
  ##Breusch-Pagan test
  obs=get(model$series)
  print(bptest(resid(model)~I(obs-resid(model))))
  
  cat("\nIndependence Tests\n")
  cat("\n--------------------\n")
  
  ##Durbin-Watson test
  print(dwtest(resid(model)~I(1:length(resid(model)))))
  
  ##Ljung-Box test
  cat("\nLjung-Box test\n")
  print(t(apply(matrix(c(1:4,(1:4)*s)),1,function(el) {
    te=Box.test(resid(model),type="Ljung-Box",lag=el)
    c(lag=(te$parameter),statistic=te$statistic[[1]],p.value=te$p.value)})))
  

  #Sample ACF vs. Teoric ACF
  par(mfrow=c(2,2),mar=c(3,3,3,3))
  acf(dades, ylim=c(-1,1) ,lag.max=36,main="Sample ACF")
  
  plot(ARMAacf(model$model$phi,model$model$theta,lag.max=36),ylim=c(-1,1), 
       type="h",xlab="Lag",  ylab="", main="ACF Teoric")
  abline(h=0)
  
  #Sample PACF vs. Teoric PACF
  pacf(dades, ylim=c(-1,1) ,lag.max=36,main="Sample PACF")
  
  plot(ARMAacf(model$model$phi,model$model$theta,lag.max=36, pacf=T),ylim=c(-1,1),
       type="h", xlab="Lag", ylab="", main="PACF Teoric")
  abline(h=0)
  par(mfrow=c(1,1))
}
################# Fi Validation #################################
```

```{r}
validation(mod1,d1d12lnserie) 
```

# Split

---Here we take the SAR(2) and SAR(4) models. Why?---

```{r}
ultim=c(2018,12)
pdq=c(2,1,0) 
PDQ=c(4,1,0)

serie1=window(serie,end=ultim+c(1,0))
lnserie1=log(serie1)
serie2=window(serie,end=ultim)
lnserie2=log(serie2)

(mod1=arima(lnserie1,order=pdq,seasonal=list(order=PDQ,period=12)))

(mod2=arima(lnserie2,order=pdq,seasonal=list(order=PDQ,period=12)))
```

both models are similar, more or less the same coef

```{r}
pred=predict(mod2,n.ahead=12)
pr<-ts(c(tail(lnserie2,1),pred$pred),start=ultim,freq=12)

se<-ts(c(0,pred$se),start=ultim,freq=12)

#Intervals
tl<-ts(exp(pr-1.96*se),start=ultim,freq=12)
tu<-ts(exp(pr+1.96*se),start=ultim,freq=12)
pr<-ts(exp(pr),start=ultim,freq=12)

reduced <- window(serie,start=ultim-c(4,0) ,end=ultim+c(1,0))

top <- max(reduced,tu)
bot <- min(reduced,tl)
mid <- top - bot

ts.plot(reduced,tl,tu,pr,lty=c(1,2,2,1),col=c(1,4,4,2),xlim=ultim[1]+c(-3,+2),ylim=c(bot-0.1*mid,top+0.1*mid),type="o",main="Model ARIMA(2,1,0)(4,1,0)12")
abline(v=(ultim[1]-3):(ultim[1]+2),lty=3,col=4)

(previs=window(cbind(tl,pr,tu,serie,error=round(serie-pr,3)),start=ultim))
```

```{r}
obs=window(serie,start=ultim)
mod.RMSE1=sqrt(sum((obs-pr)^2)/12)
mod.MAE1=sum(abs(obs-pr))/12
mod.RMSPE1=sqrt(sum(((obs-pr)/obs)^2)/12)
mod.MAPE1=sum(abs(obs-pr)/obs)/12

data.frame("RMSE"=mod.RMSE1,"MAE"=mod.MAE1,"RMSPE"=mod.RMSPE1,"MAPE"=mod.MAPE1)
```

```{r}
mCI1=mean(tu-tl)

cat("\nMean Length CI: ",mCI1)
```


# Calendar Effect

```{r}
source("CalendarEffects.r")
```

```{r}
data=c(start(lnserie)[1],start(lnserie)[2], length(lnserie))

(wTradDays=Wtrad(data))
```

```{r}
(wEast=Weaster(data))
```

```{r}
(modTD=arima(lnserie,order=pdq,seasonal=list(order=PDQ,period=12),xreg=wTradDays))
abs(modTD$coef/sqrt(diag(modTD$var.coef)))
```

```{r}
(modEa=arima(lnserie,order=pdq,seasonal=list(order=PDQ,period=12),xreg=wEast))
abs(modEa$coef/sqrt(diag(modEa$var.coef)))
```

```{r}
(modEC=arima(lnserie,order=pdq,seasonal=list(order=PDQ,period=12),xreg=data.frame(wTradDays,wEast)))
abs(modEC$coef/sqrt(diag(modEC$var.coef)))
```

```{r}
mod1$aic
modTD$aic
modEa$aic
modEC$aic
```

best model modEC

```{r}
EfecTD=coef(modEC)["wTradDays"]*wTradDays
EfecSS=coef(modEC)["wEast"]*wEast
lnserieEC=lnserie-EfecTD-EfecSS

d1d12lnserieEC=diff(diff(lnserieEC,12))
```

# Modelos EC

```{r}
par(mfrow=c(1,2))
acf(d1d12lnserieEC,ylim=c(-1,1),lag.max=120,col=c(2,rep(1,11)),lwd=2)
pacf(d1d12lnserieEC,ylim=c(-1,1),lag.max=120,col=c(rep(1,11),2),lwd=2)
par(mfrow=c(1,1))
```

MA(1), AR(2), SMA(1)

```{r}
(mod1EC=arima(lnserie,order=c(1,1,0),seasonal=list(order=c(1,1,0),period=12),xreg=data.frame(wTradDays,wEast)))
abs(mod1EC$coef/sqrt(diag(mod1EC$var.coef)))
```

```{r}
(mod2EC=arima(lnserie,order=c(0,1,2),seasonal=list(order=c(1,1,0),period=12),xreg=data.frame(wTradDays,wEast)))
abs(mod2EC$coef/sqrt(diag(mod2EC$var.coef)))
```

mod2EC best model, lower AIC

```{r}
pdq <- c(0,1,2)
PDQ <- c(1,1,0)
```


```{r}
EfecTD=coef(mod2EC)["wTradDays"]*wTradDays
EfecSS=coef(mod2EC)["wEast"]*wEast
plot(EfecTD+EfecSS)
```

```{r}
reduced <- window(serie,start=ultim-c(4,0) ,end=ultim+c(1,0))

serieEC=exp(lnserieEC)
plot(reduced,type="o")
lines(serieEC,col=2,type="o")
abline(v=2014:2017,lty=3,col=4)

window(cbind(wTradDays,wEast,serie,serieEC),start=2014)
```

```{r}
validation(mod2EC,d1d12lnserieEC)
```

## ploting calendar

```{r}
ultim=c(2018,12)

serie1=window(serie,end=ultim+c(1,0))
lnserie1=log(serie1)
serie2=window(serie,end=ultim)
lnserie2=log(serie2)
wTradDays2=window(wTradDays,end=ultim)
wEast2=window(wEast,end=ultim)

(modEC=arima(lnserie1,order=pdq,seasonal=list(order=PDQ,period=12),xreg=data.frame(wTradDays,wEast)))

(modEC2=arima(lnserie2,order=pdq,seasonal=list(order=PDQ,period=12),xreg=data.frame(wTradDays2,wEast2)))
```

```{r}
pred=predict(modEC2,n.ahead=12,newxreg=window(cbind(wTradDays,wEast),start=c(ultim[1]+1,1)))
predic=pred$pr

pr<-ts(c(tail(lnserie2,1),pred$pred),start=ultim,freq=12)

se<-ts(c(0,pred$se),start=ultim,freq=12)

#Intervals
tl<-ts(exp(pr-1.96*se),start=ultim,freq=12)
tu<-ts(exp(pr+1.96*se),start=ultim,freq=12)
pr<-ts(exp(pr),start=ultim,freq=12)

reduced <- window(serie,start=ultim-c(4,0) ,end=ultim+c(1,0))

top <- max(reduced,tu)
bot <- min(reduced,tl)
mid <- top - bot

ts.plot(reduced,tl,tu,pr,lty=c(1,2,2,1),col=c(1,4,4,2),xlim=ultim[1]+c(-3,+2),ylim=c(bot-0.1*mid,top+0.1*mid),type="o",main="Model ARIMA(0,1,2)(1,1,0)12+TD+Easter")
abline(v=(ultim[1]-3):(ultim[1]+2),lty=3,col=4)

(previs=window(cbind(tl,pr,tu,serie,error=round(serie-pr,3)),start=ultim))
```

```{r}
obs=window(serie,start=ultim)
mod.RMSE1=sqrt(sum((obs-pr)^2)/12)
mod.MAE1=sum(abs(obs-pr))/12
mod.RMSPE1=sqrt(sum(((obs-pr)/obs)^2)/12)
mod.MAPE1=sum(abs(obs-pr)/obs)/12

data.frame("RMSE"=mod.RMSE1,"MAE"=mod.MAE1,"RMSPE"=mod.RMSPE1,"MAPE"=mod.MAPE1)
```

```{r}
mCI1=mean(tu-tl)

cat("\nMean Length CI: ",mCI1)
```

# outlier treatment

```{r}
########## Atípics (Outliers) ###############################################
source("atipics2.r")
```

```{r}
# crit 2.9 cut be a good threahhold
modEC.atip=outdetec(mod1EC,dif=c(1,12),crit=3.5,LS=T)
modEC.atip$sigma
```

```{r}
atipics=modEC.atip$atip[order(modEC.atip$atip[,1]),]
month=c("Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic")

data.frame(atipics,Fecha=paste(month[(atipics[,1]-1)%%12+1],start(lnserie)[1]+((atipics[,1]-1)%/%12)),perc.Obs=exp(atipics[,3])*100)
```

```{r}
lnserie.lin=lineal(lnserie,modEC.atip$atip)
serie.lin=exp(lnserie.lin)
```

```{r}
d1d12lnserie.lin=diff(diff(lnserie.lin,12))
par(mfrow=c(1,2))
acf(d1d12lnserie.lin,ylim=c(-1,1),lag.max=120,col=c(2,rep(1,11)),lwd=2)
pacf(d1d12lnserie.lin,ylim=c(-1,1),lag.max=120,col=c(rep(1,11),2),lwd=2)
par(mfrow=c(1,1))
```

AR(2), AR(4), SAR(1), SAR(4)
```{r}
(mod1EC.lin=arima(lnserie.lin,order=c(2,1,0),seasonal=list(order=c(1,1,0),period=12),xreg=data.frame(wTradDays,wEast)))
abs(mod1EC.lin$coef/sqrt(diag(mod1EC.lin$var.coef)))
```

```{r}
(mod2EC.lin=arima(lnserie.lin,order=c(4,1,0),seasonal=list(order=c(1,1,0),period=12),xreg=data.frame(wTradDays,wEast)))
abs(mod2EC.lin$coef/sqrt(diag(mod2EC.lin$var.coef)))
```

```{r}
(mod3EC.lin=arima(lnserie.lin,order=c(2,1,0),seasonal=list(order=c(4,1,0),period=12),xreg=data.frame(wTradDays,wEast)))
abs(mod3EC.lin$coef/sqrt(diag(mod3EC.lin$var.coef)))
```

```{r}
(mod4EC.lin=arima(lnserie.lin,order=c(4,1,0),seasonal=list(order=c(4,1,0),period=12),xreg=data.frame(wTradDays,wEast)))
abs(mod4EC.lin$coef/sqrt(diag(mod4EC.lin$var.coef)))
```

model 3

```{r}
pdq <- c(2,1,0)
PDQ <- c(4,1,0)
```


```{r}
EfecTD=coef(mod3EC.lin)["wTradDays"]*wTradDays
EfecSS=coef(mod3EC.lin)["wEast"]*wEast
lnserieEC.lin=lnserie.lin-EfecTD-EfecSS
plot(lnserie-lnserieEC.lin)

plot(exp(lnserieEC.lin),col=2)
lines(serie)
```

```{r}
d12lnserieEC.lin=diff(lnserieEC.lin,12)
d1d12lnserieEC.lin=diff(d12lnserieEC.lin,1)

validation(mod3EC.lin,d1d12lnserieEC.lin)
```

# plots out

```{r}
ultim=c(2018,12)

serie.lin1=window(serie.lin,end=ultim+c(1,0))
lnserie.lin1=log(serie.lin1)
serie.lin2=window(serie.lin,end=ultim)
lnserie.lin2=log(serie.lin2)
wTradDays2=window(wTradDays,end=ultim)
wEast2=window(wEast,end=ultim)
```

```{r}
(modEC.lin=arima(lnserie.lin1,order=pdq,seasonal=list(order=PDQ,period=12),xreg=data.frame(wTradDays,wEast)))
```

```{r}
(modEC.lin2=arima(lnserie.lin2,order=pdq,seasonal=list(order=PDQ,period=12),xreg=data.frame(wTradDays2,wEast2)))
```

```{r}
pred=predict(modEC.lin2,n.ahead=12,newxreg=window(cbind(wTradDays,wEast),start=c(ultim[1]+1,1)))
predic=pred$pr
pr<-ts(c(tail(lnserie2,1),predic),start=ultim,freq=12)
se<-ts(c(0,pred$se),start=ultim,freq=12)

#Intervals
tl<-ts(exp(pr-1.96*se),start=ultim,freq=12)
tu<-ts(exp(pr+1.96*se),start=ultim,freq=12)
pr<-ts(exp(pr),start=ultim,freq=12)

ts.plot(reduced,tl,tu,pr,lty=c(1,2,2,1),col=c(1,4,4,2),xlim=ultim[1]+c(-3,2),type="o",main="Model ARIMA(0,1,1)(0,1,1)12+TD+Easter")
abline(v=(ultim[1]-3):(ultim[1]+2),lty=3,col=4)
```

# not checked

```{r}
(previs.lin=window(cbind(tl,pr,tu,serie,error=round(serie-pr,3)),start=ultim))
```

```{r}
obs=window(serie,start=ultim)
mod.RMSE3=sqrt(sum((obs-pr)^2)/12)
mod.MAE3=sum(abs(obs-pr))/12
mod.RMSPE3=sqrt(sum(((obs-pr)/obs)^2)/12)
mod.MAPE3=sum(abs(obs-pr)/obs)/12

data.frame("RMSE"=mod.RMSE3,"MAE"=mod.MAE3,"RMSPE"=mod.RMSPE3,"MAPE"=mod.MAPE3)
```

```{r}
mCI3=mean(tu-tl)

cat("\nMean Length CI: ",mCI3)
```

# Long term predictions with complete model

```{r}
##### Previsions a llarg termini amb el model complet ######
data3=c(ultim[1]+2, 1, 12)

wTradDays3=Wtrad(data3)
wEast3=Weaster(data3)
pred=predict(modEC.lin,n.ahead=12,newxreg=data.frame(wTradDays3,wEast3))
predic=pred$pr
pr<-ts(c(lnserie[length(lnserie)],predic),start=ultim+c(1,0),freq=12)
se<-ts(c(0,pred$se),start=ultim+c(1,0),freq=12)

#Intervals
tl3<-ts(exp(pr-1.96*se),start=ultim+c(1,0),freq=12)
tu3<-ts(exp(pr+1.96*se),start=ultim+c(1,0),freq=12)
pr3<-ts(exp(pr),start=ultim+c(1,0),freq=12)

ts.plot(serie,tl3,tu3,pr3,lty=c(1,2,2,1),col=c(1,4,4,2),xlim=ultim[1]+c(-2,3),type="o",main="Model ARIMA(0,1,1)(0,1,1)12")
abline(v=(ultim[1]-2):(ultim[1]+3),lty=3,col=4)
```

```{r}
par(mfrow=c(2,2),mar=c(3,3,1,1))
ts.plot(serie,previs1,lty=c(1,2,1,2),col=c(1,4,2,4),xlim=c(2017,2021),type="o",main="Model ARIMA(0,1,1)(2,1,0)12")
abline(v=2016:2021,lty=3,col=4,ylim=c(15,280))
ts.plot(serie,previs2,lty=c(1,2,1,2),col=c(1,4,2,4),xlim=c(2017,2021),type="o",main="Model ARIMA(0,1,1)(0,1,1)12+EC")
abline(v=2016:2021,lty=3,col=4,ylim=c(15,280))
ts.plot(serie,previs3,lty=c(1,2,1,2),col=c(1,4,2,4),xlim=c(2017,2021),type="o",main="Model ARIMA(0,1,1)(0,1,1)12+EC+Atip")
abline(v=2016:2021,lty=3,col=4,ylim=c(15,280))
par(mfrow=c(1,1))
```

```{r}
resul=data.frame(
  par=c(length(coef(mod1)),length(coef(mod1EC)),length(coef(mod1EC.lin))+nrow(modEC.atip$atip)),
  Sigma2Z=c(mod1$sigma2,mod1EC$sigma2,mod1EC.lin$sigma2),
  AIC=c(AIC(mod1),AIC(mod1EC),AIC(mod1EC.lin)+2*nrow(modEC.atip$atip)),
  BIC=c(BIC(mod1),BIC(mod1EC),BIC(mod1EC.lin)+log(length(serie)-13)*nrow(modEC.atip$atip)),
  RMSE=c(mod.RMSE1,mod.RMSE2,mod.RMSE3),
  MAE=c(mod.MAE1,mod.MAE2,mod.MAE3),
  RMSPE=c(mod.RMSPE1,mod.RMSPE2,mod.RMSPE3),
  MAPE=c(mod.MAPE1,mod.MAPE2,mod.MAPE3),
  meanLength=c(mCI1,mCI2,mCI3))
row.names(resul)=c("ARIMA(0,1,1)(4,1,0)12","ARIMA(0,1,1)(0,1,1)12+CalEf","ARIMA(0,1,1)(0,1,1)12+CalEf+Outliers")


resul
```

